РЕКУРСИВНЫЕ ФУНКЦИИ

  ==========  1  ==========  

Написать рекурсивную функцию с именем product, которая возвращает произведение чисел.

Функция принимает обязательным позиционно-ключевым аргументом итерируемый объект с числами в качестве элементов.
    
    Аннотация произвольного итерируемого объекта осуществляется с помощью специального типа, так называемого дженерика из модуля collections.abc, а аннотация его элементов осуществляется также как для списков:
    >>> from collections.abc import Iterable
    >>> def func(numbers: Iterable[float]):
    ...     pass
    ... 
    >>>

Функция возвращает объект float.

Подумайте об оптимизации работы функции в рамках указанных требований.

Работу написанной функции необходимо проверить.

Пример проверки:
    >>> product(range(10, 60, 10))
    12000000.0
    >>> 
    >>> product((0.12, 0.05, -0.09, 0.0, 0.21))
    0.0



  ==========  2  ==========  

Написать рекурсивную функцию с именем tree_leaves, которая считает количество листьев на дереве.

Функция принимает обязательным позиционно-ключевым аргументом список веток дерева.
    
    Роль листа будет играть строка 'leaf'.
    Каждая ветка дерева может содержать вложенные ветки и листья. То есть элементами исходного списка могут быть строки (листья) и списки (ветки), которые в свою очередь могут содержать как листья, так и строки (см. пример проверки).
    
    Поскольку речь идёт о произвольной структуре данных, то в аннотации параметра функции тип элементов не указывается.

Функция возвращает объект int.

Работу написанной функции необходимо проверить.

Пример проверки:
    >>> tree = [[[['leaf', 'leaf', 'leaf', 'leaf'], 'leaf', 'leaf', 'leaf'], [['leaf', 'leaf'], 'leaf', 'leaf'], ['leaf', 'leaf', 'leaf']], [['leaf', 'leaf'], ['leaf', 'leaf', 'leaf', 'leaf', 'leaf', 'leaf'], 'leaf', 'leaf', 'leaf'], [['leaf'], ['leaf', 'leaf', ['leaf', 'leaf', 'leaf']], 'leaf', 'leaf'], ['leaf', 'leaf', ['leaf', 'leaf'], 'leaf']]
    >>> 
    >>> tree_leaves(tree)
    38



  ==========  3  ==========  дополнительно

Написать рекурсивную функцию с именем tree_generator, которая генерирует дерево с произвольным количеством веток и листьев.

Вложенность веток также должна быть произвольной.

Функция не принимает аргументы.
    
    Роль листа должна играть строка 'leaf'.

Функция возвращает объект list.
    
    Добейтесь такого поведения, чтобы возвращаемый список не мог быть пустым, но вложенные списки (ветки) могли.

Примечание: не забывайте о функции randrange() из модуля random стандартной библиотеки.

Работу написанной функции необходимо проверить.

Пример проверки:
    >>> tree_generator()
    [[], ['leaf'], [[[[]], [['leaf'], [['leaf', 'leaf', 'leaf']], ['leaf']], [[]], ['leaf']], ['leaf', 'leaf']], [[[]], [[], [[['leaf']], [['leaf', 'leaf']], ['leaf'], [['leaf', 'leaf', 'leaf'], [[], ['leaf', 'leaf', 'leaf'], [[['leaf', 'leaf', 'leaf'], [], [[], ['leaf']], ['leaf', 'leaf', 'leaf']], ['leaf', 'leaf', 'leaf'], [['leaf']], []], ['leaf']], ['leaf'], ['leaf'], []]], [['leaf'], ['leaf', 'leaf', 'leaf']], ['leaf', 'leaf']], ['leaf', 'leaf', 'leaf']], ['leaf']]
    >>>
    >>> tree_generator()
    [[[['leaf']]], []]



  =========================

Каждая функция должна быть документирована, её параметры и возвращаемое значение должны быть аннотированы.

Работа функций проверяется в режиме инспекции файла с кодом.
Ввод и вывод в стандартные потоки результатов проверки копируются.
Копия в виде комментария помещается в конец файла с кодом задачи.

Невыполнение дополнительных задач не повлечёт снижения баллов за задание. Тем не менее они настоятельно рекомендуются к решению.

В сервис Журнал отправляется сообщение о выполнении всех частей задания со ссылкой на репозиторий.

Преподаватель пишет комментарии и правки в коде задач и обновляет файлы в удалённом репозитории.
Регулярно получайте обновления в свой локальный репозиторий из удалённого репозитория.